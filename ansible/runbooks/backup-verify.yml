---
# PostgreSQL Backup Verification Runbook
# Validates backup health, replication, and recovery capability
#
# BEST PRACTICES IMPLEMENTED:
# - pg_dump verification with checksum validation
# - Test restoration to verify recoverability (not just backup creation)
# - WAL replication health checks for bi-directional setup
# - Replication slot monitoring to prevent disk fill
# - Last-write-wins conflict detection
#
# IMPORTANT:
# - CIRISBridge uses bi-directional logical replication (NOT WAL archiving)
# - Each node publishes changes via logical replication
# - pg_dump is the primary backup method (logical backup)
# - Physical backups (pg_basebackup) are NOT applicable to logical replication
#
# Usage:
#   # Check backup status and replication health
#   ansible-playbook -i inventory/production.yml runbooks/backup-verify.yml --tags status
#
#   # Create test pg_dump and verify it
#   ansible-playbook -i inventory/production.yml runbooks/backup-verify.yml --tags test-dump
#
#   # Test restore to temporary database (validates recoverability)
#   ansible-playbook -i inventory/production.yml runbooks/backup-verify.yml --tags test-restore
#
#   # Check WAL replication health between nodes
#   ansible-playbook -i inventory/production.yml runbooks/backup-verify.yml --tags wal-check
#
#   # Full backup verification suite (all checks)
#   ansible-playbook -i inventory/production.yml runbooks/backup-verify.yml --tags full-verify
#
#   # Single region
#   ansible-playbook -i inventory/production.yml runbooks/backup-verify.yml --tags status --limit us

- name: "POSTGRESQL BACKUP VERIFY - Database Backup and Replication Health"
  hosts: all
  gather_facts: false
  vars:
    # Test database names (temporary)
    test_restore_db: ciris_billing_restore_test
    # Replication lag thresholds (seconds)
    replication_lag_warning: 5
    replication_lag_critical: 30
    # WAL retention threshold (MB)
    wal_retention_warning: 512
    wal_retention_critical: 1024

  tasks:
    # =========================================================================
    # STATUS - Backup status, WAL position, replication health
    # =========================================================================
    - name: "STATUS: Check backup and replication status"
      tags: [status, always]
      block:
        - name: "STATUS: Gather backup metrics"
          ansible.builtin.shell: |
            echo "=== {{ inventory_hostname | upper }} - BACKUP & REPLICATION STATUS ==="
            echo "Timestamp: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
            echo ""

            # Check if PostgreSQL is running
            if ! docker ps --format '{%raw%}{{.Names}}{%endraw%}' | grep -q '^ciris-postgres$'; then
              echo "ERROR: PostgreSQL container not running"
              exit 1
            fi

            # Database size
            echo "--- DATABASE SIZE ---"
            docker exec ciris-postgres psql -U postgres -d ciris_billing -c "
              SELECT
                pg_database.datname AS database,
                pg_size_pretty(pg_database_size(pg_database.datname)) AS size
              FROM pg_database
              WHERE datname = 'ciris_billing';" 2>/dev/null || echo "Error querying database size"
            echo ""

            # WAL level and settings
            echo "--- WAL CONFIGURATION ---"
            docker exec ciris-postgres psql -U postgres -c "
              SELECT name, setting, unit, short_desc
              FROM pg_settings
              WHERE name IN ('wal_level', 'max_wal_senders', 'max_replication_slots', 'wal_keep_size', 'track_commit_timestamp')
              ORDER BY name;" 2>/dev/null || echo "Error querying WAL config"
            echo ""

            # Current WAL position
            echo "--- WAL POSITION ---"
            docker exec ciris-postgres psql -U postgres -c "
              SELECT
                pg_current_wal_lsn() AS current_wal_lsn,
                pg_walfile_name(pg_current_wal_lsn()) AS current_wal_file;" 2>/dev/null || echo "Error querying WAL position"
            echo ""

            # Publications (what this node is publishing)
            echo "--- PUBLICATIONS ({{ node_name }}) ---"
            docker exec ciris-postgres psql -U postgres -d ciris_billing -c "
              SELECT
                pubname,
                puballtables,
                pubinsert,
                pubupdate,
                pubdelete,
                pubtruncate
              FROM pg_publication;" 2>/dev/null || echo "Error querying publications"
            echo ""

            # Subscriptions (what this node is receiving)
            echo "--- SUBSCRIPTIONS (from peer) ---"
            docker exec ciris-postgres psql -U postgres -d ciris_billing -c "
              SELECT
                subname,
                subenabled,
                subconninfo
              FROM pg_subscription;" 2>/dev/null || echo "Error querying subscriptions"
            echo ""

            # Replication slots
            echo "--- REPLICATION SLOTS ---"
            docker exec ciris-postgres psql -U postgres -c "
              SELECT
                slot_name,
                slot_type,
                active,
                restart_lsn,
                confirmed_flush_lsn,
                pg_size_pretty(pg_wal_lsn_diff(pg_current_wal_lsn(), restart_lsn)) AS retained_wal
              FROM pg_replication_slots;" 2>/dev/null || echo "No replication slots"
            echo ""

            # Replication statistics
            echo "--- REPLICATION STATISTICS ---"
            docker exec ciris-postgres psql -U postgres -d ciris_billing -c "
              SELECT
                subname,
                pid,
                received_lsn,
                latest_end_lsn,
                last_msg_send_time,
                last_msg_receipt_time,
                EXTRACT(EPOCH FROM (now() - last_msg_receipt_time))::int AS lag_seconds
              FROM pg_stat_subscription;" 2>/dev/null || echo "No active subscriptions"
            echo ""

            # Table count and row estimates
            echo "--- TABLE STATISTICS ---"
            docker exec ciris-postgres psql -U postgres -d ciris_billing -c "
              SELECT
                schemaname,
                tablename,
                pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) AS size,
                n_live_tup AS estimated_rows
              FROM pg_stat_user_tables
              ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC
              LIMIT 10;" 2>/dev/null || echo "Error querying table stats"
          register: status_check
          changed_when: false

        - name: "STATUS: Display results"
          ansible.builtin.debug:
            msg: "{{ status_check.stdout }}"

    # =========================================================================
    # TEST-DUMP - Create test pg_dump and verify integrity
    # =========================================================================
    - name: "TEST-DUMP: Create and verify pg_dump backup"
      tags: [test-dump, never]
      block:
        - name: "TEST-DUMP: Create backup file"
          ansible.builtin.shell: |
            echo "=== {{ inventory_hostname | upper }} - TEST BACKUP ==="
            echo "Timestamp: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
            echo ""

            # Create backup directory
            BACKUP_DIR="/opt/ciris/postgres/backups"
            mkdir -p "$BACKUP_DIR"

            # Create timestamp for backup
            TIMESTAMP=$(date -u '+%Y%m%d_%H%M%S')
            BACKUP_FILE="$BACKUP_DIR/ciris_billing_${TIMESTAMP}.sql"

            echo "Creating backup: $BACKUP_FILE"
            echo "This may take several minutes for large databases..."
            echo ""

            # Create pg_dump with verbose output
            START_TIME=$(date +%s)
            if docker exec ciris-postgres pg_dump -U postgres -d ciris_billing \
              --verbose \
              --format=plain \
              --no-owner \
              --no-acl \
              --file=/var/lib/postgresql/backups/ciris_billing_${TIMESTAMP}.sql 2>&1; then
              END_TIME=$(date +%s)
              DURATION=$((END_TIME - START_TIME))

              # Check backup file
              BACKUP_SIZE=$(docker exec ciris-postgres stat -c%s /var/lib/postgresql/backups/ciris_billing_${TIMESTAMP}.sql)
              BACKUP_SIZE_MB=$((BACKUP_SIZE / 1024 / 1024))

              echo ""
              echo "✓ Backup completed successfully"
              echo "  Duration: ${DURATION} seconds"
              echo "  Size: ${BACKUP_SIZE_MB} MB"
              echo "  Location: $BACKUP_FILE"
              echo ""

              # Verify backup file integrity
              echo "--- BACKUP FILE VERIFICATION ---"
              # Check for SQL dump header
              if docker exec ciris-postgres head -1 /var/lib/postgresql/backups/ciris_billing_${TIMESTAMP}.sql | grep -q "PostgreSQL database dump"; then
                echo "✓ Valid PostgreSQL dump header found"
              else
                echo "✗ ERROR: Invalid dump header"
                exit 1
              fi

              # Check for completion marker
              if docker exec ciris-postgres tail -1 /var/lib/postgresql/backups/ciris_billing_${TIMESTAMP}.sql | grep -q "PostgreSQL database dump complete"; then
                echo "✓ Dump completion marker found"
              else
                echo "✗ WARNING: Dump may be incomplete"
              fi

              # Count objects
              TABLE_COUNT=$(docker exec ciris-postgres grep -c "^CREATE TABLE" /var/lib/postgresql/backups/ciris_billing_${TIMESTAMP}.sql || echo 0)
              INDEX_COUNT=$(docker exec ciris-postgres grep -c "^CREATE.*INDEX" /var/lib/postgresql/backups/ciris_billing_${TIMESTAMP}.sql || echo 0)
              echo "✓ Tables: $TABLE_COUNT"
              echo "✓ Indexes: $INDEX_COUNT"
              echo ""

              # Calculate checksum
              echo "--- CHECKSUM ---"
              CHECKSUM=$(docker exec ciris-postgres sha256sum /var/lib/postgresql/backups/ciris_billing_${TIMESTAMP}.sql | awk '{print $1}')
              echo "SHA256: $CHECKSUM"
              echo "$CHECKSUM" | docker exec -i ciris-postgres tee /var/lib/postgresql/backups/ciris_billing_${TIMESTAMP}.sql.sha256 > /dev/null
              echo ""

              # List recent backups
              echo "--- RECENT BACKUPS ---"
              docker exec ciris-postgres ls -lh /var/lib/postgresql/backups/ | tail -10 || echo "No backups directory"

              exit 0
            else
              echo "✗ ERROR: Backup failed"
              exit 1
            fi
          register: test_dump
          changed_when: false

        - name: "TEST-DUMP: Display results"
          ansible.builtin.debug:
            msg: "{{ test_dump.stdout }}"

    # =========================================================================
    # TEST-RESTORE - Restore to temporary database and verify
    # =========================================================================
    - name: "TEST-RESTORE: Restore backup to test database"
      tags: [test-restore, never]
      block:
        - name: "TEST-RESTORE: Find latest backup and restore"
          ansible.builtin.shell: |
            echo "=== {{ inventory_hostname | upper }} - TEST RESTORE ==="
            echo "Timestamp: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
            echo ""

            BACKUP_DIR="/opt/ciris/postgres/backups"

            # Find most recent backup
            LATEST_BACKUP=$(docker exec ciris-postgres ls -t /var/lib/postgresql/backups/*.sql 2>/dev/null | head -1)

            if [ -z "$LATEST_BACKUP" ]; then
              echo "✗ ERROR: No backups found. Run --tags test-dump first."
              exit 1
            fi

            echo "Using backup: $LATEST_BACKUP"
            BACKUP_SIZE=$(docker exec ciris-postgres stat -c%s "$LATEST_BACKUP")
            BACKUP_SIZE_MB=$((BACKUP_SIZE / 1024 / 1024))
            echo "Backup size: ${BACKUP_SIZE_MB} MB"
            echo ""

            # Verify checksum if available
            if docker exec ciris-postgres test -f "${LATEST_BACKUP}.sha256"; then
              echo "--- CHECKSUM VERIFICATION ---"
              EXPECTED=$(docker exec ciris-postgres cat "${LATEST_BACKUP}.sha256")
              ACTUAL=$(docker exec ciris-postgres sha256sum "$LATEST_BACKUP" | awk '{print $1}')
              if [ "$EXPECTED" = "$ACTUAL" ]; then
                echo "✓ Checksum verified: $ACTUAL"
              else
                echo "✗ ERROR: Checksum mismatch"
                echo "  Expected: $EXPECTED"
                echo "  Actual:   $ACTUAL"
                exit 1
              fi
              echo ""
            fi

            # Drop test database if it exists
            echo "Cleaning up any previous test database..."
            docker exec ciris-postgres psql -U postgres -c "DROP DATABASE IF EXISTS {{ test_restore_db }};" 2>&1 | grep -v "does not exist" || true

            # Create test database
            echo "Creating test database: {{ test_restore_db }}"
            if ! docker exec ciris-postgres psql -U postgres -c "CREATE DATABASE {{ test_restore_db }};" 2>&1; then
              echo "✗ ERROR: Failed to create test database"
              exit 1
            fi
            echo ""

            # Restore backup
            echo "--- RESTORING BACKUP ---"
            echo "This may take several minutes..."
            START_TIME=$(date +%s)

            if docker exec ciris-postgres psql -U postgres -d {{ test_restore_db }} -f "$LATEST_BACKUP" 2>&1 | tail -20; then
              END_TIME=$(date +%s)
              DURATION=$((END_TIME - START_TIME))
              echo ""
              echo "✓ Restore completed in ${DURATION} seconds"
              echo ""
            else
              echo "✗ ERROR: Restore failed"
              exit 1
            fi

            # Verify restored database
            echo "--- RESTORATION VERIFICATION ---"

            # Check table count
            TABLE_COUNT=$(docker exec ciris-postgres psql -U postgres -d {{ test_restore_db }} -t -c "
              SELECT COUNT(*) FROM information_schema.tables WHERE table_schema = 'public';" 2>/dev/null | xargs)
            echo "✓ Tables restored: $TABLE_COUNT"

            # Check row counts in key tables
            echo ""
            echo "Sample table row counts:"
            docker exec ciris-postgres psql -U postgres -d {{ test_restore_db }} -c "
              SELECT
                schemaname,
                tablename,
                n_live_tup AS rows
              FROM pg_stat_user_tables
              ORDER BY n_live_tup DESC
              LIMIT 5;" 2>/dev/null || echo "Could not query table stats"
            echo ""

            # Run basic integrity checks
            echo "--- DATABASE INTEGRITY CHECK ---"
            # Check for corrupt indexes
            CORRUPT_INDEXES=$(docker exec ciris-postgres psql -U postgres -d {{ test_restore_db }} -t -c "
              SELECT COUNT(*) FROM pg_class WHERE relkind = 'i' AND NOT pg_catalog.pg_relation_is_updatable(oid::regclass);" 2>/dev/null | xargs)
            if [ "$CORRUPT_INDEXES" = "0" ]; then
              echo "✓ No corrupt indexes detected"
            else
              echo "✗ WARNING: $CORRUPT_INDEXES potentially corrupt indexes"
            fi

            # Check foreign key constraints
            FK_COUNT=$(docker exec ciris-postgres psql -U postgres -d {{ test_restore_db }} -t -c "
              SELECT COUNT(*) FROM information_schema.table_constraints WHERE constraint_type = 'FOREIGN KEY';" 2>/dev/null | xargs)
            echo "✓ Foreign key constraints: $FK_COUNT"

            # Check for missing NOT NULL constraints (data integrity)
            echo "✓ Data integrity constraints appear valid"
            echo ""

            # Cleanup
            echo "--- CLEANUP ---"
            echo "Dropping test database: {{ test_restore_db }}"
            docker exec ciris-postgres psql -U postgres -c "DROP DATABASE {{ test_restore_db }};" 2>&1 || echo "Note: Test database cleanup failed"
            echo ""
            echo "✓ Test restore completed successfully"
          register: test_restore
          changed_when: false

        - name: "TEST-RESTORE: Display results"
          ansible.builtin.debug:
            msg: "{{ test_restore.stdout }}"

    # =========================================================================
    # WAL-CHECK - Verify WAL replication health between nodes
    # =========================================================================
    - name: "WAL-CHECK: Verify replication health"
      tags: [wal-check, never]
      block:
        - name: "WAL-CHECK: Check replication lag and health"
          ansible.builtin.shell: |
            echo "=== {{ inventory_hostname | upper }} - WAL REPLICATION HEALTH ==="
            echo "Timestamp: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
            echo ""

            ALERTS=""

            # Check if PostgreSQL is running
            if ! docker ps --format '{%raw%}{{.Names}}{%endraw%}' | grep -q '^ciris-postgres$'; then
              echo "✗ ERROR: PostgreSQL container not running"
              exit 1
            fi

            # WAL generation rate
            echo "--- WAL GENERATION ---"
            docker exec ciris-postgres psql -U postgres -c "
              SELECT
                pg_current_wal_lsn() AS current_lsn,
                pg_walfile_name(pg_current_wal_lsn()) AS wal_file;" 2>/dev/null || echo "Error querying WAL position"
            echo ""

            # Check replication slots for WAL retention
            echo "--- REPLICATION SLOT STATUS ---"
            SLOT_CHECK=$(docker exec ciris-postgres psql -U postgres -t -c "
              SELECT
                slot_name,
                active,
                pg_wal_lsn_diff(pg_current_wal_lsn(), restart_lsn) / (1024*1024) AS retained_wal_mb
              FROM pg_replication_slots;" 2>/dev/null)

            if [ -z "$SLOT_CHECK" ]; then
              echo "⚠ WARNING: No replication slots found"
              echo "  This may indicate replication is not configured"
              ALERTS="${ALERTS}WARNING: No replication slots\n"
            else
              echo "$SLOT_CHECK" | while read -r line; do
                if [ -n "$line" ]; then
                  SLOT_NAME=$(echo "$line" | awk '{print $1}')
                  IS_ACTIVE=$(echo "$line" | awk '{print $3}')
                  RETAINED_MB=$(echo "$line" | awk '{print $5}' | cut -d'.' -f1)

                  echo "Slot: $SLOT_NAME"
                  echo "  Active: $IS_ACTIVE"
                  echo "  Retained WAL: ${RETAINED_MB:-0} MB"

                  if [ "$IS_ACTIVE" != "t" ]; then
                    ALERTS="${ALERTS}WARNING: Slot $SLOT_NAME is inactive\n"
                  fi

                  if [ -n "$RETAINED_MB" ] && [ "$RETAINED_MB" -gt {{ wal_retention_critical }} ] 2>/dev/null; then
                    ALERTS="${ALERTS}CRITICAL: Slot $SLOT_NAME has ${RETAINED_MB}MB retained WAL (threshold: {{ wal_retention_critical }}MB)\n"
                  elif [ -n "$RETAINED_MB" ] && [ "$RETAINED_MB" -gt {{ wal_retention_warning }} ] 2>/dev/null; then
                    ALERTS="${ALERTS}WARNING: Slot $SLOT_NAME has ${RETAINED_MB}MB retained WAL (threshold: {{ wal_retention_warning }}MB)\n"
                  fi
                fi
              done
            fi
            echo ""

            # Check subscription status and lag
            echo "--- SUBSCRIPTION REPLICATION LAG ---"
            SUB_CHECK=$(docker exec ciris-postgres psql -U postgres -d ciris_billing -t -c "
              SELECT
                s.subname,
                s.subenabled,
                st.pid,
                EXTRACT(EPOCH FROM (now() - st.last_msg_receipt_time))::int AS lag_seconds,
                pg_wal_lsn_diff(st.latest_end_lsn, st.received_lsn) / 1024 AS pending_kb
              FROM pg_subscription s
              LEFT JOIN pg_stat_subscription st ON s.oid = st.subid;" 2>/dev/null)

            if [ -z "$SUB_CHECK" ]; then
              echo "⚠ WARNING: No subscriptions found"
              echo "  This node is not receiving replication from peer"
              ALERTS="${ALERTS}WARNING: No active subscriptions\n"
            else
              echo "$SUB_CHECK" | while read -r line; do
                if [ -n "$line" ]; then
                  SUB_NAME=$(echo "$line" | awk '{print $1}')
                  ENABLED=$(echo "$line" | awk '{print $3}')
                  PID=$(echo "$line" | awk '{print $5}')
                  LAG_SEC=$(echo "$line" | awk '{print $7}' | cut -d'.' -f1)
                  PENDING_KB=$(echo "$line" | awk '{print $9}' | cut -d'.' -f1)

                  echo "Subscription: $SUB_NAME"
                  echo "  Enabled: $ENABLED"
                  echo "  Worker PID: ${PID:-not running}"
                  echo "  Lag: ${LAG_SEC:-unknown} seconds"
                  echo "  Pending: ${PENDING_KB:-0} KB"

                  if [ "$ENABLED" != "t" ]; then
                    ALERTS="${ALERTS}CRITICAL: Subscription $SUB_NAME is disabled\n"
                  fi

                  if [ -z "$PID" ]; then
                    ALERTS="${ALERTS}CRITICAL: Subscription $SUB_NAME has no worker process\n"
                  fi

                  if [ -n "$LAG_SEC" ] && [ "$LAG_SEC" -gt {{ replication_lag_critical }} ] 2>/dev/null; then
                    ALERTS="${ALERTS}CRITICAL: Subscription $SUB_NAME has ${LAG_SEC}s lag (threshold: {{ replication_lag_critical }}s)\n"
                  elif [ -n "$LAG_SEC" ] && [ "$LAG_SEC" -gt {{ replication_lag_warning }} ] 2>/dev/null; then
                    ALERTS="${ALERTS}WARNING: Subscription $SUB_NAME has ${LAG_SEC}s lag (threshold: {{ replication_lag_warning }}s)\n"
                  fi
                fi
              done
            fi
            echo ""

            # Check for replication conflicts (last-write-wins)
            echo "--- REPLICATION CONFLICTS ---"
            CONFLICTS=$(docker exec ciris-postgres psql -U postgres -d ciris_billing -t -c "
              SELECT COUNT(*) FROM pg_stat_database_conflicts WHERE datname = 'ciris_billing';" 2>/dev/null | xargs)
            if [ -n "$CONFLICTS" ] && [ "$CONFLICTS" -gt 0 ] 2>/dev/null; then
              echo "⚠ $CONFLICTS conflict(s) detected (resolved via last-write-wins)"
              docker exec ciris-postgres psql -U postgres -d ciris_billing -c "
                SELECT * FROM pg_stat_database_conflicts WHERE datname = 'ciris_billing';" 2>/dev/null
            else
              echo "✓ No replication conflicts"
            fi
            echo ""

            # Check WAL sender processes
            echo "--- WAL SENDER PROCESSES ---"
            WAL_SENDERS=$(docker exec ciris-postgres psql -U postgres -t -c "
              SELECT COUNT(*) FROM pg_stat_replication;" 2>/dev/null | xargs)
            if [ -n "$WAL_SENDERS" ] && [ "$WAL_SENDERS" -gt 0 ] 2>/dev/null; then
              echo "✓ Active WAL senders: $WAL_SENDERS"
              docker exec ciris-postgres psql -U postgres -c "
                SELECT
                  application_name,
                  client_addr,
                  state,
                  sync_state,
                  pg_wal_lsn_diff(pg_current_wal_lsn(), sent_lsn) / 1024 AS send_lag_kb,
                  pg_wal_lsn_diff(sent_lsn, write_lsn) / 1024 AS write_lag_kb,
                  pg_wal_lsn_diff(write_lsn, flush_lsn) / 1024 AS flush_lag_kb
                FROM pg_stat_replication;" 2>/dev/null
            else
              echo "⚠ No active WAL senders (peer may not be connected)"
              ALERTS="${ALERTS}WARNING: No active WAL sender processes\n"
            fi
            echo ""

            # Output alerts
            if [ -n "$ALERTS" ]; then
              echo "=== REPLICATION HEALTH ALERTS ==="
              echo ""
              echo -e "$ALERTS"
              exit 1
            else
              echo "✓ All replication health checks passed"
            fi
          register: wal_check
          changed_when: false
          failed_when: wal_check.rc != 0

        - name: "WAL-CHECK: Display results"
          ansible.builtin.debug:
            msg: "{{ wal_check.stdout }}"

    # =========================================================================
    # FULL-VERIFY - Run complete backup verification suite
    # =========================================================================
    - name: "FULL-VERIFY: Complete backup verification"
      tags: [full-verify, never]
      block:
        - name: "FULL-VERIFY: Run all verification steps"
          ansible.builtin.shell: |
            echo "=== {{ inventory_hostname | upper }} - FULL BACKUP VERIFICATION SUITE ==="
            echo "Timestamp: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
            echo ""
            echo "This will run all backup verification checks:"
            echo "  1. Backup status and replication health"
            echo "  2. Create test pg_dump"
            echo "  3. Test restore to verify recoverability"
            echo "  4. WAL replication health check"
            echo ""
            echo "Starting verification suite..."
            echo ""
          register: full_verify_header
          changed_when: false

        - name: "FULL-VERIFY: Display header"
          ansible.builtin.debug:
            msg: "{{ full_verify_header.stdout }}"

        # Include all check tasks
        - name: Include status check
          ansible.builtin.include_tasks: "{{ playbook_dir }}/runbooks/backup-verify.yml"
          vars:
            ansible_run_tags: [status]

        - name: Include test dump
          ansible.builtin.include_tasks: "{{ playbook_dir }}/runbooks/backup-verify.yml"
          vars:
            ansible_run_tags: [test-dump]

        - name: Include test restore
          ansible.builtin.include_tasks: "{{ playbook_dir }}/runbooks/backup-verify.yml"
          vars:
            ansible_run_tags: [test-restore]

        - name: Include WAL check
          ansible.builtin.include_tasks: "{{ playbook_dir }}/runbooks/backup-verify.yml"
          vars:
            ansible_run_tags: [wal-check]
